<!DOCTYPE html>
<html>

<head>
    <title>Color Music Grid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="gridCanvas"></canvas>

    <script>
        // Initialize canvas to fullscreen
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        });

        // Audio context and notes setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const activeNotes = [];
        const MAX_NOTES = 4;

        // Musical scale (C major pentatonic for always-pleasant combinations)
        const SCALE_NOTES = [
            196.00,  // G3
            220.00,  // A3
            246.94,  // B3
            261.63,  // C4
            293.66,  // D4
            329.63,  // E4
            349.23,  // F4
            392.00,  // G4
            440.00,  // A4
            493.88,  // B4
            523.25,  // C5
            587.33,  // D5
            659.25,  // E5
            698.46   // F5
        ];

        // Grid and center point setup
        const GRID_SIZE = 24;
        const cellWidth = canvas.width / GRID_SIZE;
        const cellHeight = canvas.height / GRID_SIZE;

        let centerPoint = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            hue: Math.random() * 360,
            frequency: SCALE_NOTES[0]
        };

        // Modify wave types to match "moods"
        const WAVE_TYPES = ['sine', 'triangle', 'square', 'sawtooth'];

        // Define mood ranges (hue values)
        const MOODS = {
            BLUE: { min: 180, max: 240, wave: 'sine' },     // Sad/soft (sine waves)
            GREEN: { min: 90, max: 150, wave: 'triangle' },  // Natural (triangle waves)
            YELLOW: { min: 45, max: 89, wave: 'square' },   // Happy/bright (square waves)
            RED: { min: 0, max: 44, wave: 'sawtooth' }      // Intense (sawtooth waves)
        };

        function getMoodFromHue(hue) {
            for (const mood of Object.values(MOODS)) {
                if (hue >= mood.min && hue <= mood.max) return mood;
            }
            return MOODS.BLUE; // default
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const gridX = Math.floor(x / cellWidth);
            const gridY = Math.floor(y / cellHeight);

            // Get color at clicked position
            const distanceFromCenter = Math.sqrt(
                Math.pow(gridX - GRID_SIZE/2, 2) +
                Math.pow(gridY - GRID_SIZE/2, 2)
            );

            const hueShift = (distanceFromCenter * 5) % 360;
            const hue = (centerPoint.hue + hueShift) % 360;
            const saturation = 100;
            const lightness = Math.max(60 - distanceFromCenter * 3, 20);

            // Determine musical properties from color
            const mood = getMoodFromHue(hue);
            const waveType = mood.wave;
            
            // Lightness determines pitch (higher = higher pitch)
            const noteIndex = Math.floor((lightness / 100) * (SCALE_NOTES.length - 1));
            const frequency = SCALE_NOTES[noteIndex];

            // Saturation affects duration (more saturated = longer note)
            const noteDuration = 0.1 + (saturation / 100) * 2; // 0.1 to 2.1 seconds

            // Update center point
            centerPoint.hue = hue;
            centerPoint.frequency = frequency;

            // Manage active notes (keep up to 4 playing)
            if (activeNotes.length >= MAX_NOTES) {
                const oldestNote = activeNotes.shift();
                oldestNote.gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                setTimeout(() => oldestNote.oscillator.stop(), 500);
            }

            const noteObj = playNote(frequency, waveType, noteDuration);
            activeNotes.push(noteObj);

            drawGrid();
        });

        function playNote(frequency, waveType, duration) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = waveType;
            oscillator.frequency.value = frequency;

            // Adjust gain based on wave type
            const baseGain = waveType === 'sine' ? 0.3 : 
                            waveType === 'triangle' ? 0.25 :
                            waveType === 'square' ? 0.15 : 0.1;

            // Initial attack
            gainNode.gain.setValueAtTime(baseGain, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(baseGain/2, audioContext.currentTime + 0.1);
            
            // Remove the automatic fade out - let the note sustain
            gainNode.gain.exponentialRampToValueAtTime(baseGain/3, audioContext.currentTime + 0.2);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();

            return { oscillator, gainNode, frequency };
        }

        function drawGrid() {
            const centerGridX = Math.floor(GRID_SIZE / 2);
            const centerGridY = Math.floor(GRID_SIZE / 2);

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const pixelX = x * cellWidth;
                    const pixelY = y * cellHeight;

                    const distanceFromCenter = Math.sqrt(
                        Math.pow(x - centerGridX, 2) +
                        Math.pow(y - centerGridY, 2)
                    );

                    const hueShift = (distanceFromCenter * 5) % 360;
                    const hue = (centerPoint.hue + hueShift) % 360;

                    // Enhanced visual feedback for active notes
                    const saturation = 100;
                    const lightness = Math.max(60 - distanceFromCenter * 3, 20);
                    const alpha = 1 - (distanceFromCenter / GRID_SIZE);

                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                    ctx.fillRect(pixelX, pixelY, cellWidth + 1, cellHeight + 1);
                }
            }
        }

        // Initial draw
        drawGrid();
    </script>
</body>

</html>