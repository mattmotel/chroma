<!DOCTYPE html>
<html>

<head>
    <title>Color Music Grid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="gridCanvas"></canvas>

    <script>
        // Initialize canvas to fullscreen
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        });

        // Audio context and notes setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const activeNotes = [];
        const MAX_NOTES = 4;

        // Musical scale (pentatonic scale)
        const SCALE_NOTES = [
            261.63,  // C4
            293.66,  // D4
            329.63,  // E4
            392.00,  // G4
            440.00,  // A4
            523.25,  // C5
            587.33,  // D5
            659.25,  // E5
            783.99,  // G5
            880.00   // A5
        ];

        // Grid and center point setup
        const GRID_SIZE = 24;
        const cellWidth = canvas.width / GRID_SIZE;
        const cellHeight = canvas.height / GRID_SIZE;

        let centerPoint = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            hue: Math.random() * 360,
            frequency: SCALE_NOTES[0]
        };

        // Modify wave types to match "moods"
        const WAVE_TYPES = ['sine', 'triangle', 'square', 'sawtooth'];

        // Enhanced mood definitions with more musical properties
        const MOODS = {
            BLUE: { 
                min: 180, max: 240, 
                wave: 'sine',
                gainMod: 0.4,    
                attack: 0.1      
            },     
            GREEN: { 
                min: 90, max: 150, 
                wave: 'triangle',
                gainMod: 0.35,   
                attack: 0.08     
            },  
            YELLOW: { 
                min: 45, max: 89, 
                wave: 'triangle',
                gainMod: 0.3,    
                attack: 0.05     
            },   
            RED: { 
                min: 0, max: 44, 
                wave: 'triangle',
                gainMod: 0.25,   
                attack: 0.03     
            }      
        };

        function getMoodFromHue(hue) {
            for (const mood of Object.values(MOODS)) {
                if (hue >= mood.min && hue <= mood.max) return mood;
            }
            return MOODS.BLUE; // default
        }

        // Helper function to get nearest note in scale
        function getNearestNote(desiredFreq) {
            return SCALE_NOTES.reduce((prev, curr) => {
                return (Math.abs(curr - desiredFreq) < Math.abs(prev - desiredFreq) ? curr : prev);
            });
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const gridX = Math.floor(x / cellWidth);
            const gridY = Math.floor(y / cellHeight);

            // Check if click is in the "color jump" zone (bottom right corner)
            if (gridX > GRID_SIZE - 4 && gridY > GRID_SIZE - 4) {
                // Big color jump (90 degrees) when clicking in bottom right
                centerPoint.hue = (centerPoint.hue + 90) % 360;
                drawGrid();
                return;
            }

            // Get base note from Y position (top = higher, bottom = lower)
            const yPos = 1 - (gridY / GRID_SIZE); // 0 to 1, inverted
            const noteIndex = Math.floor(yPos * (SCALE_NOTES.length - 1));
            let frequency = SCALE_NOTES[noteIndex];

            // Adjust frequency slightly based on color
            const hueInfluence = (centerPoint.hue / 360) * 20; // Small variation based on hue
            frequency = getNearestNote(frequency + hueInfluence);

            // Enhanced musical properties from color
            const mood = getMoodFromHue(centerPoint.hue);
            const waveType = mood.wave;
            
            // Lightness affects both pitch and volume
            const lightness = Math.max(60 - gridY * 3, 20);

            // Saturation affects note length and tremolo
            const noteDuration = 0.1 + (100 / 100) * 2;

            // Update center point
            centerPoint.hue = centerPoint.hue;
            centerPoint.frequency = frequency;

            if (activeNotes.length >= MAX_NOTES) {
                const oldestNote = activeNotes.shift();
                oldestNote.gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                setTimeout(() => oldestNote.oscillator.stop(), 500);
            }

            const noteObj = playNote(frequency, waveType, noteDuration, mood, lightness);
            activeNotes.push(noteObj);

            drawGrid();
        });

        function playNote(frequency, waveType, duration, mood, lightness) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = waveType;
            oscillator.frequency.value = frequency;

            // Adjust base gain for better balance
            const baseGain = mood.gainMod * (lightness / 100) * 0.5; // Reduced overall volume

            // Smoother attack and release
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
                baseGain, 
                audioContext.currentTime + mood.attack
            );

            // Add subtle reverb effect
            const convolver = audioContext.createConvolver();
            // ... (would need to add impulse response for reverb)

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();

            return { oscillator, gainNode, frequency };
        }

        function drawGrid() {
            const centerGridX = Math.floor(GRID_SIZE / 2);
            const centerGridY = Math.floor(GRID_SIZE / 2);

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const pixelX = x * cellWidth;
                    const pixelY = y * cellHeight;

                    const distanceFromCenter = Math.sqrt(
                        Math.pow(x - centerGridX, 2) +
                        Math.pow(y - centerGridY, 2)
                    );

                    const hueShift = (distanceFromCenter * 5) % 360;
                    const hue = (centerPoint.hue + hueShift) % 360;

                    // Enhanced visual feedback for active notes
                    const saturation = 100;
                    const lightness = Math.max(60 - distanceFromCenter * 3, 20);
                    const alpha = 1 - (distanceFromCenter / GRID_SIZE);

                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                    ctx.fillRect(pixelX, pixelY, cellWidth + 1, cellHeight + 1);
                }
            }

            // Draw color jump zone indicator
            ctx.fillStyle = `hsla(${(centerPoint.hue + 90) % 360}, 100%, 50%, 0.3)`;
            for (let x = GRID_SIZE - 4; x < GRID_SIZE; x++) {
                for (let y = GRID_SIZE - 4; y < GRID_SIZE; y++) {
                    ctx.fillRect(
                        x * cellWidth, 
                        y * cellHeight, 
                        cellWidth + 1, 
                        cellHeight + 1
                    );
                }
            }
        }

        // Initial draw
        drawGrid();
    </script>
</body>

</html>